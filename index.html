<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Acetime - Road Racer</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #111;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
        }
        #title {
            font-size: clamp(18px, 5vw, 32px);
            color: #ff00ff;
            text-shadow: 2px 2px #00ffff;
            margin-bottom: 4px;
            text-align: center;
        }
        #hud {
            display: flex;
            justify-content: space-between;
            width: min(95vw, 420px);
            font-size: clamp(8px, 2.5vw, 13px);
            color: #0f0;
            padding: 4px 8px;
        }
        #gameCanvas {
            border: 3px solid #00ffff;
            display: block;
            background: #333;
            image-rendering: pixelated;
        }
        #controls {
            display: none;
            justify-content: center;
            gap: 16px;
            margin-top: 10px;
        }
        .ctrl-btn {
            width: 70px; height: 70px;
            border: 3px solid #00ffff;
            background: rgba(0,255,255,0.12);
            color: #0ff;
            font-size: 28px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .ctrl-btn:active { background: rgba(0,255,255,0.35); }
        #overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.82);
            z-index: 10;
            color: #fff;
            text-align: center;
            padding: 20px;
        }
        #overlay h1 {
            font-size: clamp(20px, 6vw, 40px);
            color: #ff00ff;
            text-shadow: 2px 2px #00ffff;
            margin-bottom: 16px;
        }
        #overlay .sub {
            font-size: clamp(9px, 2.8vw, 14px);
            color: #0ff;
            margin-bottom: 10px;
            line-height: 1.8;
        }
        #overlay .score-display {
            font-size: clamp(12px, 3.5vw, 22px);
            color: #ff0;
            margin: 12px 0;
        }
        #overlay .hs {
            font-size: clamp(9px, 2.5vw, 13px);
            color: #0f0;
            margin-bottom: 16px;
        }
        .play-btn {
            padding: 14px 32px;
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(11px, 3vw, 16px);
            background: #ff00ff;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-shadow: 1px 1px #00ffff;
            margin-top: 10px;
        }
        .play-btn:hover { background: #ff44ff; }
        .play-btn.small { font-size: clamp(9px, 2.2vw, 12px); padding: 10px 18px; }
        #nameRow {
            display: none;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }
        #nameInput {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(10px, 2.5vw, 14px);
            padding: 8px 10px;
            background: #222;
            color: #0ff;
            border: 2px solid #0ff;
            border-radius: 6px;
            width: 160px;
            text-align: center;
            outline: none;
        }
        #nameInput::placeholder { color: #555; }
        #submitBtn {
            font-family: 'Press Start 2P', monospace;
            font-size: clamp(9px, 2.2vw, 12px);
            padding: 8px 14px;
            background: #0a0;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        #submitBtn:hover { background: #0c0; }
        #leaderboard {
            display: none;
            margin-top: 10px;
            width: 100%;
            max-width: 320px;
        }
        #leaderboard h3 {
            font-size: clamp(10px, 2.8vw, 14px);
            color: #ff0;
            margin-bottom: 6px;
        }
        #lbBody {
            font-size: clamp(7px, 2vw, 10px);
            color: #ccc;
            text-align: left;
        }
        .lb-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }
        .lb-row.gold { color: #ffd700; }
        .lb-row.silver { color: #c0c0c0; }
        .lb-row.bronze { color: #cd7f32; }
        .lb-rank { width: 24px; }
        .lb-name { flex: 1; }
        .lb-score { width: 60px; text-align: right; }
        #backLink {
            margin-top: 8px;
            font-size: clamp(8px, 2vw, 11px);
        }
        #backLink a { color: #888; text-decoration: none; }
        #backLink a:hover { color: #0ff; }
    </style>
</head>
<body>
<div id="wrapper">
    <div id="title">ROAD RACER</div>
    <div id="hud">
        <span>SCORE: <span id="scoreDisplay">0</span></span>
        <span>BEST: <span id="bestDisplay">0</span></span>
        <span>SPEED: <span id="speedDisplay">1</span></span>
    </div>
    <div style="position:relative; display:inline-block;">
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h1>ROAD RACER</h1>
            <div class="sub" id="instructions"></div>
            <div class="score-display" id="finalScore" style="display:none;"></div>
            <div class="hs" id="highScoreMsg" style="display:none;"></div>
            <div id="nameRow">
                <input type="text" id="nameInput" placeholder="YOUR NAME" maxlength="16" autocomplete="off">
                <button id="submitBtn">SAVE</button>
            </div>
            <div id="leaderboard">
                <h3>TOP 10</h3>
                <div id="lbBody"></div>
            </div>
            <button class="play-btn" id="playBtn">START</button>
        </div>
    </div>
    <div id="controls">
        <div class="ctrl-btn" id="btnLeft">&#9664;</div>
        <div class="ctrl-btn" id="btnRight">&#9654;</div>
    </div>
    <div id="backLink" style="margin-top:8px;font-size:clamp(8px,2vw,11px);color:#555;">ACETIME</div>
</div>

<script>
// ============================================================
//  ROAD RACER - Endless highway dodge game
// ============================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ----- Responsive canvas sizing -----
const BASE_W = 400;
const BASE_H = 650;
let scale = 1;

function resizeCanvas() {
    const maxW = Math.min(window.innerWidth * 0.95, 420);
    const maxH = window.innerHeight - 140;
    scale = Math.min(maxW / BASE_W, maxH / BASE_H);
    canvas.style.width = (BASE_W * scale) + 'px';
    canvas.style.height = (BASE_H * scale) + 'px';
    canvas.width = BASE_W;
    canvas.height = BASE_H;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ----- Detect mobile -----
const isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || ('ontouchstart' in window);
if (isMobile) {
    document.getElementById('controls').style.display = 'flex';
}

// ----- Game constants -----
const LANE_COUNT = 5;
const ROAD_LEFT = 50;
const ROAD_RIGHT = BASE_W - 50;
const ROAD_W = ROAD_RIGHT - ROAD_LEFT;
const LANE_W = ROAD_W / LANE_COUNT;
const SHOULDER = 12;

const CAR_W = 36;
const CAR_H = 60;

const COLORS = {
    road: '#444',
    shoulder: '#888',
    line: '#ff0',
    lineDash: '#fff',
    grass: '#1a5c1a',
    player: '#00ccff',
    playerAccent: '#0088cc',
    playerWindow: '#002244',
    coin: '#ffd700',
    shield: '#00ff88',
};

const ENEMY_COLORS = ['#ff3333','#ff8833','#ffdd33','#33cc33','#cc33ff','#ff33aa','#ffffff'];

// ----- Game state -----
let state = 'menu'; // menu | playing | dead
let score = 0;
let bestScore = parseInt(localStorage.getItem('roadRacerBest') || '0');
let speed = 2;
let baseSpeed = 2;
let frame = 0;
let roadOffset = 0;
let shieldTimer = 0;
let combo = 0;
let lastDodgeFrame = 0;

// Player
let player = { lane: 2, x: 0, y: 0, targetX: 0, bobble: 0 };

// Objects
let enemies = [];
let coins = [];
let particles = [];
let sparks = [];

// Input state
let inputLeft = false;
let inputRight = false;
let canSwitch = true;

// ----- Helper functions -----
function laneX(lane) {
    return ROAD_LEFT + LANE_W * lane + LANE_W / 2;
}

function resetGame() {
    score = 0;
    speed = 2;
    baseSpeed = 2;
    frame = 0;
    roadOffset = 0;
    shieldTimer = 0;
    combo = 0;
    lastDodgeFrame = 0;
    player.lane = 2;
    player.x = laneX(2);
    player.y = BASE_H - 100;
    player.targetX = player.x;
    player.bobble = 0;
    enemies = [];
    coins = [];
    particles = [];
    sparks = [];
}

// ----- Spawn logic -----
let spawnTimer = 0;
let coinTimer = 0;

function spawnEnemy() {
    const lane = Math.floor(Math.random() * LANE_COUNT);
    const colorIdx = Math.floor(Math.random() * ENEMY_COLORS.length);
    // Vary enemy speed slightly
    const espeed = speed * (0.3 + Math.random() * 0.4);
    enemies.push({
        lane, x: laneX(lane), y: -CAR_H - 20,
        w: CAR_W, h: CAR_H,
        speed: espeed,
        color: ENEMY_COLORS[colorIdx],
        passed: false
    });
}

function spawnCoin() {
    const lane = Math.floor(Math.random() * LANE_COUNT);
    const type = Math.random() < 0.12 ? 'shield' : 'coin';
    coins.push({
        lane, x: laneX(lane), y: -20,
        r: 10, type, bobble: Math.random() * Math.PI * 2
    });
}

// ----- Particles -----
function emitParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6 - 2,
            life: 30 + Math.random() * 20,
            maxLife: 50,
            color,
            r: 2 + Math.random() * 3
        });
    }
}

function emitSparks(x, y) {
    for (let i = 0; i < 15; i++) {
        sparks.push({
            x, y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 20 + Math.random() * 15,
            color: Math.random() < 0.5 ? '#ff0' : '#f80'
        });
    }
}

// ----- Update -----
function update() {
    if (state !== 'playing') return;
    frame++;

    // Increase speed over time
    baseSpeed = 2 + frame * 0.0012;
    speed = baseSpeed;

    // Road scroll
    roadOffset = (roadOffset + speed * 3) % 40;

    // Player lane switching
    if (inputLeft && canSwitch) {
        if (player.lane > 0) player.lane--;
        canSwitch = false;
    }
    if (inputRight && canSwitch) {
        if (player.lane < LANE_COUNT - 1) player.lane++;
        canSwitch = false;
    }
    if (!inputLeft && !inputRight) canSwitch = true;

    player.targetX = laneX(player.lane);
    player.x += (player.targetX - player.x) * 0.18;
    player.bobble += 0.15;

    // Shield timer
    if (shieldTimer > 0) shieldTimer--;

    // Spawn enemies
    const spawnRate = Math.max(25, 70 - frame * 0.02);
    spawnTimer++;
    if (spawnTimer >= spawnRate) {
        spawnTimer = 0;
        spawnEnemy();
        // At higher speeds, sometimes spawn 2
        if (speed > 5 && Math.random() < 0.3) {
            spawnEnemy();
        }
    }

    // Spawn coins
    coinTimer++;
    if (coinTimer >= 50 + Math.random() * 40) {
        coinTimer = 0;
        spawnCoin();
    }

    // Update enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.y += speed * 2.5 - e.speed;

        // Check if player dodged this car
        if (!e.passed && e.y > player.y + CAR_H / 2) {
            e.passed = true;
            score += 10;
            // Combo for close dodges
            if (e.lane === player.lane || Math.abs(e.lane - player.lane) <= 1) {
                if (frame - lastDodgeFrame < 30) {
                    combo++;
                    score += combo * 5;
                }
                lastDodgeFrame = frame;
            }
        }

        // Collision check
        const dx = Math.abs(player.x - e.x);
        const dy = Math.abs(player.y - e.y);
        if (dx < CAR_W * 0.8 && dy < CAR_H * 0.75) {
            if (shieldTimer > 0) {
                // Shield absorbs hit
                shieldTimer = 0;
                emitSparks(e.x, e.y);
                enemies.splice(i, 1);
                score += 50;
                continue;
            }
            // Crash!
            emitParticles(player.x, player.y, '#f00', 30);
            emitParticles(player.x, player.y, '#ff0', 20);
            emitSparks(player.x, player.y);
            state = 'dead';
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('roadRacerBest', bestScore);
            }
            showOverlay(true);
            return;
        }

        if (e.y > BASE_H + 50) {
            enemies.splice(i, 1);
        }
    }

    // Update coins
    for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.y += speed * 2.2;
        c.bobble += 0.1;

        const dx = Math.abs(player.x - c.x);
        const dy = Math.abs(player.y - c.y);
        if (dx < 25 && dy < 25) {
            if (c.type === 'coin') {
                score += 25;
                emitParticles(c.x, c.y, COLORS.coin, 8);
            } else {
                shieldTimer = 300; // ~5 seconds
                emitParticles(c.x, c.y, COLORS.shield, 12);
            }
            coins.splice(i, 1);
            continue;
        }
        if (c.y > BASE_H + 30) coins.splice(i, 1);
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Update sparks
    for (let i = sparks.length - 1; i >= 0; i--) {
        const s = sparks[i];
        s.x += s.vx;
        s.y += s.vy;
        s.vx *= 0.95;
        s.vy *= 0.95;
        s.life--;
        if (s.life <= 0) sparks.splice(i, 1);
    }

    // Decay combo
    if (frame - lastDodgeFrame > 90) combo = 0;

    // Update HUD
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('bestDisplay').textContent = bestScore;
    document.getElementById('speedDisplay').textContent = Math.floor(baseSpeed * 30) + ' km/h';
}

// ----- Draw -----
function drawCar(x, y, w, h, color, accent, windowColor, isPlayer) {
    const cx = x - w / 2;
    const cy = y - h / 2;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(cx + 3, cy + 3, w, h);

    // Body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(cx, cy, w, h, 5);
    ctx.fill();

    // Accent stripe
    ctx.fillStyle = accent;
    ctx.fillRect(cx + 4, cy + h * 0.3, w - 8, 4);

    // Windshield
    ctx.fillStyle = windowColor;
    if (isPlayer) {
        ctx.fillRect(cx + 6, cy + h * 0.55, w - 12, h * 0.18);
        // Rear window
        ctx.fillRect(cx + 8, cy + h * 0.12, w - 16, h * 0.13);
    } else {
        ctx.fillRect(cx + 6, cy + h * 0.15, w - 12, h * 0.18);
        ctx.fillRect(cx + 8, cy + h * 0.7, w - 16, h * 0.13);
    }

    // Headlights / taillights
    if (isPlayer) {
        // Taillights (red at top since player faces up)
        ctx.fillStyle = '#f00';
        ctx.fillRect(cx + 2, cy + 2, 6, 4);
        ctx.fillRect(cx + w - 8, cy + 2, 6, 4);
        // Headlights
        ctx.fillStyle = '#fff';
        ctx.fillRect(cx + 2, cy + h - 6, 6, 4);
        ctx.fillRect(cx + w - 8, cy + h - 6, 6, 4);
    } else {
        // Headlights
        ctx.fillStyle = '#ff8';
        ctx.fillRect(cx + 2, cy + h - 6, 6, 4);
        ctx.fillRect(cx + w - 8, cy + h - 6, 6, 4);
        // Taillights
        ctx.fillStyle = '#f00';
        ctx.fillRect(cx + 2, cy + 2, 6, 4);
        ctx.fillRect(cx + w - 8, cy + 2, 6, 4);
    }

    // Wheels
    ctx.fillStyle = '#222';
    ctx.fillRect(cx - 3, cy + 6, 5, 12);
    ctx.fillRect(cx + w - 2, cy + 6, 5, 12);
    ctx.fillRect(cx - 3, cy + h - 18, 5, 12);
    ctx.fillRect(cx + w - 2, cy + h - 18, 5, 12);
}

function draw() {
    // Grass
    ctx.fillStyle = COLORS.grass;
    ctx.fillRect(0, 0, BASE_W, BASE_H);

    // Road surface
    ctx.fillStyle = COLORS.road;
    ctx.fillRect(ROAD_LEFT - SHOULDER, 0, ROAD_W + SHOULDER * 2, BASE_H);

    // Shoulder lines
    ctx.fillStyle = COLORS.shoulder;
    ctx.fillRect(ROAD_LEFT - SHOULDER, 0, SHOULDER, BASE_H);
    ctx.fillRect(ROAD_RIGHT, 0, SHOULDER, BASE_H);

    // Solid edge lines
    ctx.fillStyle = '#fff';
    ctx.fillRect(ROAD_LEFT - 2, 0, 3, BASE_H);
    ctx.fillRect(ROAD_RIGHT - 1, 0, 3, BASE_H);

    // Lane dashes
    ctx.fillStyle = COLORS.lineDash;
    for (let lane = 1; lane < LANE_COUNT; lane++) {
        const lx = ROAD_LEFT + LANE_W * lane;
        for (let dy = -40 + roadOffset; dy < BASE_H; dy += 40) {
            ctx.fillRect(lx - 1, dy, 2, 20);
        }
    }

    // Center line (yellow double)
    const centerLane = Math.floor(LANE_COUNT / 2);
    const cx = ROAD_LEFT + LANE_W * centerLane;
    ctx.fillStyle = COLORS.line;
    for (let dy = -40 + roadOffset; dy < BASE_H; dy += 40) {
        ctx.fillRect(cx - 3, dy, 2, 20);
        ctx.fillRect(cx + 1, dy, 2, 20);
    }

    // Grass detail stripes
    ctx.fillStyle = '#1e6e1e';
    for (let dy = -40 + (roadOffset * 0.5) % 80; dy < BASE_H; dy += 80) {
        ctx.fillRect(0, dy, ROAD_LEFT - SHOULDER, 8);
        ctx.fillRect(ROAD_RIGHT + SHOULDER, dy, BASE_W - ROAD_RIGHT - SHOULDER, 8);
    }

    // Coins
    for (const c of coins) {
        const bob = Math.sin(c.bobble) * 2;
        if (c.type === 'coin') {
            ctx.fillStyle = COLORS.coin;
            ctx.beginPath();
            ctx.arc(c.x, c.y + bob, c.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#b8860b';
            ctx.beginPath();
            ctx.arc(c.x, c.y + bob, c.r - 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS.coin;
            ctx.font = '9px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('$', c.x, c.y + bob + 3);
        } else {
            // Shield pickup
            ctx.fillStyle = COLORS.shield;
            ctx.beginPath();
            ctx.arc(c.x, c.y + bob, c.r + 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#005533';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('S', c.x, c.y + bob + 4);
        }
    }

    // Enemy cars
    for (const e of enemies) {
        const darkerColor = darken(e.color, 0.6);
        drawCar(e.x, e.y, e.w, e.h, e.color, darkerColor, '#112', false);
    }

    // Player car
    if (state === 'playing' || state === 'menu') {
        const bob = Math.sin(player.bobble) * 0.5;
        // Shield glow
        if (shieldTimer > 0) {
            ctx.save();
            const alpha = shieldTimer < 60 ? (Math.sin(frame * 0.3) * 0.3 + 0.3) : 0.3;
            ctx.fillStyle = `rgba(0,255,136,${alpha})`;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 35, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = COLORS.shield;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }
        drawCar(player.x, player.y + bob, CAR_W, CAR_H, COLORS.player, COLORS.playerAccent, COLORS.playerWindow, true);
    }

    // Particles
    for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * alpha, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Sparks
    for (const s of sparks) {
        ctx.fillStyle = s.color;
        ctx.fillRect(s.x, s.y, 2, 2);
    }

    // Combo display
    if (combo > 1 && state === 'playing') {
        ctx.save();
        ctx.fillStyle = '#ff0';
        ctx.font = '12px "Press Start 2P"';
        ctx.textAlign = 'center';
        const comboAlpha = Math.min(1, (frame - lastDodgeFrame < 60) ? 1 : 0);
        ctx.globalAlpha = comboAlpha;
        ctx.fillText(`COMBO x${combo}!`, BASE_W / 2, 50);
        ctx.restore();
    }

    // Shield timer bar
    if (shieldTimer > 0 && state === 'playing') {
        const barW = 80;
        const barH = 6;
        const bx = player.x - barW / 2;
        const by = player.y - CAR_H / 2 - 14;
        ctx.fillStyle = '#333';
        ctx.fillRect(bx, by, barW, barH);
        ctx.fillStyle = COLORS.shield;
        ctx.fillRect(bx, by, barW * (shieldTimer / 300), barH);
    }
}

function darken(hex, factor) {
    let r = parseInt(hex.slice(1,3), 16);
    let g = parseInt(hex.slice(3,5), 16);
    let b = parseInt(hex.slice(5,7), 16);
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    return `rgb(${r},${g},${b})`;
}

// ----- Game loop -----
function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// ----- Highscore API -----
let lastSavedScore = -1;

async function fetchHighscores() {
    try {
        const res = await fetch('/api/highscores');
        return await res.json();
    } catch { return []; }
}

async function postHighscore(name, sc) {
    try {
        const res = await fetch('/api/highscores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, score: sc })
        });
        return await res.json();
    } catch { return []; }
}

function renderLeaderboard(scores) {
    const lb = document.getElementById('lbBody');
    if (!scores.length) { lb.innerHTML = '<div style="color:#666">No scores yet</div>'; return; }
    lb.innerHTML = scores.map((s, i) => {
        const cls = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
        return `<div class="lb-row ${cls}"><span class="lb-rank">${i+1}.</span><span class="lb-name">${s.name}</span><span class="lb-score">${s.score}</span></div>`;
    }).join('');
}

// Submit score
document.getElementById('submitBtn').addEventListener('click', async () => {
    const nameInput = document.getElementById('nameInput');
    const name = nameInput.value.trim();
    if (!name) { nameInput.focus(); return; }
    document.getElementById('submitBtn').textContent = '...';
    const scores = await postHighscore(name, score);
    renderLeaderboard(scores);
    document.getElementById('nameRow').style.display = 'none';
    document.getElementById('submitBtn').textContent = 'SAVE';
    lastSavedScore = score;
    localStorage.setItem('roadRacerName', name);
});

document.getElementById('nameInput').addEventListener('keydown', (e) => {
    e.stopPropagation();
    if (e.key === 'Enter') document.getElementById('submitBtn').click();
});

// ----- Overlay -----
async function showOverlay(isDead) {
    const overlay = document.getElementById('overlay');
    const finalScore = document.getElementById('finalScore');
    const hsMsg = document.getElementById('highScoreMsg');
    const btn = document.getElementById('playBtn');
    const instructions = document.getElementById('instructions');
    const nameRow = document.getElementById('nameRow');
    const leaderboard = document.getElementById('leaderboard');
    const nameInput = document.getElementById('nameInput');

    overlay.style.display = 'flex';

    if (isDead) {
        document.querySelector('#overlay h1').textContent = 'GAME OVER';
        finalScore.style.display = 'block';
        finalScore.textContent = `SCORE: ${score}`;
        if (score >= bestScore && score > 0) {
            hsMsg.style.display = 'block';
            hsMsg.textContent = 'NEW HIGH SCORE!';
        } else {
            hsMsg.style.display = 'block';
            hsMsg.textContent = `BEST: ${bestScore}`;
        }
        // Show name input if score hasn't been saved yet
        nameRow.style.display = 'flex';
        nameInput.value = localStorage.getItem('roadRacerName') || '';
        setTimeout(() => nameInput.focus(), 100);

        // Show leaderboard
        leaderboard.style.display = 'block';
        const scores = await fetchHighscores();
        renderLeaderboard(scores);

        btn.textContent = 'PLAY AGAIN';
        btn.classList.add('small');
        instructions.innerHTML = '';
    } else {
        document.querySelector('#overlay h1').textContent = 'ROAD RACER';
        finalScore.style.display = 'none';
        hsMsg.style.display = bestScore > 0 ? 'block' : 'none';
        hsMsg.textContent = bestScore > 0 ? `BEST: ${bestScore}` : '';
        nameRow.style.display = 'none';
        btn.classList.remove('small');
        btn.textContent = 'START';

        // Show leaderboard on start screen too
        leaderboard.style.display = 'block';
        const scores = await fetchHighscores();
        renderLeaderboard(scores);

        if (isMobile) {
            instructions.innerHTML = 'Tap LEFT / RIGHT to switch lanes<br>Dodge traffic, collect coins!<br>Green S = Shield';
        } else {
            instructions.innerHTML = 'Arrow Keys or A/D to steer<br>Dodge traffic, collect coins!<br>Green S = Shield';
        }
    }
}

function hideOverlay() {
    document.getElementById('overlay').style.display = 'none';
}

// ----- Input handling: Keyboard -----
document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
        inputLeft = true;
        e.preventDefault();
    }
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
        inputRight = true;
        e.preventDefault();
    }
    if ((e.key === ' ' || e.key === 'Enter') && state !== 'playing') {
        startGame();
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') inputLeft = false;
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') inputRight = false;
});

// ----- Input handling: Touch -----
// On-screen buttons
document.getElementById('btnLeft').addEventListener('touchstart', (e) => { e.preventDefault(); inputLeft = true; });
document.getElementById('btnLeft').addEventListener('touchend', (e) => { e.preventDefault(); inputLeft = false; canSwitch = true; });
document.getElementById('btnRight').addEventListener('touchstart', (e) => { e.preventDefault(); inputRight = true; });
document.getElementById('btnRight').addEventListener('touchend', (e) => { e.preventDefault(); inputRight = false; canSwitch = true; });

// Swipe detection on canvas
let touchStartX = null;
let touchStartY = null;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;

    // Tap left/right half of canvas
    const rect = canvas.getBoundingClientRect();
    const relX = t.clientX - rect.left;
    if (relX < rect.width / 2) {
        inputLeft = true;
        setTimeout(() => { inputLeft = false; canSwitch = true; }, 100);
    } else {
        inputRight = true;
        setTimeout(() => { inputRight = false; canSwitch = true; }, 100);
    }
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (touchStartX === null) return;
    const dx = e.touches[0].clientX - touchStartX;
    if (Math.abs(dx) > 30) {
        if (dx < 0) {
            inputLeft = true;
            setTimeout(() => { inputLeft = false; canSwitch = true; }, 80);
        } else {
            inputRight = true;
            setTimeout(() => { inputRight = false; canSwitch = true; }, 80);
        }
        touchStartX = e.touches[0].clientX;
    }
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchStartX = null;
});

// ----- Start game -----
function startGame() {
    resetGame();
    hideOverlay();
    state = 'playing';
}

document.getElementById('playBtn').addEventListener('click', startGame);

// ----- Init -----
document.getElementById('bestDisplay').textContent = bestScore;
showOverlay(false);
resetGame();
player.x = laneX(2);
player.targetX = player.x;
gameLoop();

// roundRect polyfill for older browsers
if (!ctx.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (typeof r === 'number') r = [r, r, r, r];
        this.moveTo(x + r[0], y);
        this.lineTo(x + w - r[1], y);
        this.quadraticCurveTo(x + w, y, x + w, y + r[1]);
        this.lineTo(x + w, y + h - r[2]);
        this.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
        this.lineTo(x + r[3], y + h);
        this.quadraticCurveTo(x, y + h, x, y + h - r[3]);
        this.lineTo(x, y + r[0]);
        this.quadraticCurveTo(x, y, x + r[0], y);
        this.closePath();
    };
}
</script>
</body>
</html>
